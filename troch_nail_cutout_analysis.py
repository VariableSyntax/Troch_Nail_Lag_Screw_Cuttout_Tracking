# -*- coding: utf-8 -*-
"""Troch_Nail_Cutout_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IXIWUot0LBsTpkmzz6W6KZLhWQ6Eldex
"""

# Troch Nail Cutout Analysis
# Written by Joshua McGuckin (Research Engineer, Globus Medical, Inc.)

# Troch Nail Cutout Analysis

##**Import packages**
import numpy as np
import pandas as pd
import tkinter as tk
from tkinter import filedialog
import matplotlib.pyplot as plt
import matplotlib.figure as figure
from matplotlib.figure import Figure
from matplotlib.widgets import RectangleSelector
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from sklearn.linear_model import LinearRegression
from scipy.optimize import curve_fit
from scipy.signal import find_peaks
# import PySimpleGUI as sg
from tabulate import tabulate
!pip install mpld3
import mpld3
from mpld3 import plugins

# Type in the filepath and start/stop endpoints
filepath = '/content/Troch Nail - Tracking_MT24-347_Spec 106_Hip Fastener_Left Posterior_2024_10_21_150936_001_cal.xlsx'

time_start = 12.436978921829905
time_stop = 6876.683364826654

# Extract important columns from dataset ---------------------------------------
dataset = pd.read_excel(filepath) # Import data from cal file as a dataframe

def extract_data(dataset):  # Extract important columns from dataset
    # Extract key measurements (time, x- y- z- relatives) as 1D arrays
    time = np.array(dataset.iloc[:, 0])
    relative_x = np.array(dataset.iloc[:, 1])
    relative_y = np.array(dataset.iloc[:, 2])
    relative_z = np.array(dataset.iloc[:, 3])

    # Calculate the scaled relative for each dimension (normalized to initial
    # value)
    scaled_relative_x = relative_x[:] - relative_x[0]
    scaled_relative_y = relative_y[:] - relative_y[0]
    scaled_relative_z = relative_z[:] - relative_z[0]

    # Calculate rotation of the femoral head around the centroid of the
    # femoral head or Neck Rotation (deg)
    neck_rot = (scaled_relative_x[:] + scaled_relative_z[:])/2

    # Calculate rotation of the femoral around the longitudinal screw axis
    screw_axis = scaled_relative_x[:] * np.sin(
        np.radians(46)) + scaled_relative_z[:] * np.cos(np.radians(46))

    time_updated = scaled_relative_x_updated = scaled_relative_y_updated = []
    scaled_relative_z_updated = neck_rot_updated = screw_axis_updated = []

    for i in range(len(time)):  # Iterate through all rows of x- y- z- relatives
        # & remove all empty rows if RB1 falls below RB2, there will be a
        # discontinuity in calculated femoral neck rotation correct for this
        # by subtracting the X-direction motion by 360 deg
        if neck_rot[i] > 100: # 100 deg change is considered anamolous
            neck_rot[i] = (scaled_relative_x[i] - 360 + scaled_relative_z[i])/2
            screw_axis[i] = (scaled_relative_x[i] - 360) * np.sin(
                np.radians(46)) + scaled_relative_z[i] * np.cos(np.radians(46))
        # Remove all empty rows from the data
        if str(scaled_relative_x[i]) != 'nan' and str(
            scaled_relative_y[i]) != 'nan' and str(scaled_relative_z[i]) !=\
                'nan':
            time_updated = np.append(time_updated, time[i])
            scaled_relative_x_updated = np.append(scaled_relative_x_updated,
                                                  scaled_relative_x[i])
            scaled_relative_y_updated = np.append(scaled_relative_y_updated,
                                                  scaled_relative_y[i])
            scaled_relative_z_updated = np.append(scaled_relative_z_updated,
                                                  scaled_relative_z[i])
            neck_rot_updated = np.append(neck_rot_updated, neck_rot[i])
            screw_axis_updated = np.append(screw_axis_updated, screw_axis[i])

    # Update all arrays (empty rows removed)
    time = np.array(time_updated)
    scaled_relative_x = np.array(scaled_relative_x_updated)
    scaled_relative_y = np.array(scaled_relative_y_updated)
    scaled_relative_z = np.array(scaled_relative_z_updated)
    scaled_neck_rot = np.array(neck_rot_updated)
    scaled_screw_axis = np.array(screw_axis_updated)

    # Rename scaled relatives
    raw_x = scaled_relative_x
    raw_y = scaled_relative_y
    raw_z = scaled_relative_z

    return time, raw_x, raw_y, raw_z, scaled_neck_rot, scaled_screw_axis

# Extra data from the dataset
[time, raw_x, varus_collapse, raw_z, fem_neck_rot, fem_screw_rot
 ] = extract_data(dataset)

# Extract index of start and end time points in ROI
def Selected_time_range(time_start, time_stop):
    delta_start = abs(time - time_start)
    delta_stop = abs(time - time_stop)

    # Find the index of the time points that most closesly match the user
    # defined time points
    start = np.where(delta_start == min(delta_start))[0][0]
    stop = np.where(delta_stop == min(delta_stop))[0][0]

    return start, stop

[start, stop] = Selected_time_range(time_start, time_stop)

# Check to make sure you have logical start/stop times
# print(start)
# print(stop)

# Select the data in the Varus Collapse and Neck Rotation datasets that is
# within this specified timespan
varus_collapse_updated = varus_collapse[start:stop]
varus_collapse_updated = varus_collapse_updated - varus_collapse_updated[0]
fem_neck_rot_updated = fem_neck_rot[start:stop]
fem_screw_rot_updated = fem_screw_rot[start:stop]
time_updated = time[start:stop]
peaks_varus, _ = find_peaks(varus_collapse_updated, width=3)
valleys_varus, _ = find_peaks(-varus_collapse_updated, width=3)
peaks_neck, _ = find_peaks(fem_neck_rot_updated, width=3)
valleys_neck, _ = find_peaks(-fem_neck_rot_updated, width=3)
peaks_screw, _ = find_peaks(fem_screw_rot_updated, width=3)
valleys_screw, _ = find_peaks(-fem_screw_rot_updated, width=3)

# Plot Varus Collapse and Neck Rotation simultaneously ------------------------

# Create the output figure
plt.plot(time_updated, varus_collapse_updated)
plt.plot(time_updated, fem_neck_rot_updated)
plt.plot(time_updated, fem_screw_rot_updated)
plt.plot(time_updated[peaks_varus],
         varus_collapse_updated[peaks_varus], "o--")
plt.plot(time_updated[valleys_varus],
         varus_collapse_updated[valleys_varus], "o--")
plt.plot(time_updated[peaks_neck], fem_neck_rot_updated[peaks_neck], "o--")
plt.plot(time_updated[valleys_neck],
         fem_neck_rot_updated[valleys_neck], "o--"), \
plt.plot(time_updated[peaks_screw], fem_screw_rot_updated[peaks_screw], "o--"),\
plt.plot(time_updated[valleys_screw],
         fem_screw_rot_updated[valleys_screw], "o--"), \
plt.plot(time_updated[peaks_varus],
 (np.max(varus_collapse_updated[peaks_varus])-5)*np.ones([len(peaks_varus)]),
         linestyle='--')
plt.xlabel('Time (sec)')
plt.ylabel('Displacement (°)')
plt.legend(['Varus Collapse', 'Neck Rotation',
            'Rotation Around Screw', 'Peaks: Varus Collapse',
            'Valleys: Varus Collapse', 'Peaks: Neck Rotation',
            'Valleys: Neck Rotation', 'Peaks: Rotation Around Screw',
            'Valleys: Rotation Around Screw'])

# Calculate 5 deg Varus Collapse as the 5 deg drop from the peak Varus
# Collapse displacement
loc_varus_collapse = np.where(varus_collapse_updated[peaks_varus] <= (np.max(
    varus_collapse_updated[peaks_varus])-5))
loc_max_varus = np.where(varus_collapse_updated[peaks_varus] == np.max(
    varus_collapse_updated[peaks_varus]))
# Deifne 5 deg Varus Collapse as where Max Varus Collapse decreases by 5 deg
try:
  thres_varus_collapse = loc_varus_collapse[0][np.array(np.where(
      loc_varus_collapse > loc_max_varus[0])[1][0])]
  option = 0
except: # If there is no point 5 deg less than the Max Varus Collapse after the
# Max Varus Collapse peak, take the last point of the Varus Collapse as the 5
# deg Varus Collapse threshold
  thres_varus_collapse = len(peaks_varus)
  option = 1

print('Cycles to 5° Varus Collapse: ' + str(thres_varus_collapse))

# Calculate Neck Rotation at 5 deg Varus Collapse
try:
  time_thres_varus = time_updated[peaks_varus][thres_varus_collapse]

except:
  time_thres_varus = time_updated[peaks_varus][len(peaks_varus)-1]

loc_neck_rot = fem_neck_rot_updated[peaks_neck]
thres_neck_rot = loc_neck_rot[np.where(np.abs(
    time_updated[peaks_neck] - time_thres_varus) == np.min(np.abs(
    time_updated[peaks_neck] - time_thres_varus)))][0]

print('Neck Rotation at 5° Varus Collapse: ' + str(round(
    thres_neck_rot, 2)) + '°')

# Calculate Rotation of Femoral Head around the Screw at 5 deg Varus Collapse
loc_fem_screw = fem_screw_rot_updated[peaks_screw]
thres_fem_screw = loc_fem_screw[np.where(np.abs(
    time_updated[peaks_screw] - time_thres_varus) == np.min(np.abs(
    time_updated[peaks_screw] - time_thres_varus)))][0]

print('Rotation of the Femoral Head around the Screw at 5° Varus Collapse: '
      + str(round(thres_fem_screw, 2)) + '°')

if option == 0:
  time_plt = time_updated[peaks_varus][thres_varus_collapse]
else:
  time_plt = time_updated[peaks_varus][len(peaks_varus)-1]

plt.plot((time_plt)*np.ones([len(peaks_varus)]),
        np.linspace(np.max(varus_collapse_updated), np.min(
            fem_screw_rot_updated), len(peaks_varus)), linestyle='--')
# plt.plot(np.linspace(np.min(time_updated), np.max(time_updated), len(
#    peaks_neck)), (thres_neck_rot)*np.ones([len(peaks_neck)]), linestyle='--')

mpld3.display()

# Output Summarized Analysis ---------------------------------------------

# Create header
head = ["Variable", "Value"]

# Assign data
Analyzed_output = [["Cycles to 5° Varus Collapse", thres_varus_collapse],
 ["Neck Rotation at 5° Varus Collapse (°)", round(thres_neck_rot,3)],
  ["Rotation Around Screw at 5° Varus Collapse (°)", round(thres_fem_screw,3)],
   ["Max Cycles",len(peaks_varus)],
   ["Max Varus Collapse (°)", varus_collapse_updated[peaks_varus]
    [len(peaks_varus)-1]-np.max(varus_collapse_updated[peaks_varus])],
    ["Max Neck Rotation (°)", np.min(fem_neck_rot_updated[peaks_neck])],
     ["Max Rotation Around Screw (°)", np.min(fem_screw_rot_updated[peaks_screw])]]

# Display table
print(tabulate(Analyzed_output, headers=head))

# Create a DataFrame
Summary_table = pd.DataFrame(Analyzed_output, columns = head)
# print(Summary_table)

# Save the summary table and peaks-valleys data as an excel

# Check the size of all peaks and valleys arrays
# print(len(peaks_neck))
# print(len(valleys_neck))
# print(len(peaks_varus))
# print(len(valleys_varus))

# Find the max array size for all peaks and valleys arrays
max_size = np.max([len(peaks_varus), len(peaks_neck), len(peaks_screw),
                   len(valleys_varus), len(valleys_neck), len(valleys_screw)])

# Pad time, varus collapse, and neck rotation (peaks and valleys) so they can
# all be added to the same dataframe
# Varus Collapse: Peaks
Time_Varus_Collapse_peaks = np.pad(time_updated[peaks_varus],
 (0, max_size-len(peaks_varus)), mode='constant', constant_values=0)
Varus_Collapse_peaks = np.pad(varus_collapse_updated[peaks_varus],
 (0, max_size-len(peaks_varus)), mode='constant', constant_values=0)

# Varus Collapse: Valleys
Time_Varus_Collapse_valleys = np.pad(time_updated[valleys_varus],
 (0, max_size-len(valleys_varus)), mode='constant', constant_values=0)
Varus_Collapse_valleys = np.pad(varus_collapse_updated[valleys_varus],
 (0, max_size-len(valleys_varus)), mode='constant', constant_values=0)

# Neck Rotation: Peaks
Time_Neck_Rotation_peaks = np.pad(time_updated[peaks_neck],
 (0, max_size-len(peaks_neck)), mode='constant', constant_values=0)
Neck_Rotation_peaks = np.pad(fem_neck_rot_updated[peaks_neck],
 (0, max_size-len(peaks_neck)), mode='constant', constant_values=0)

# Neck Rotation: Valleys
Time_Neck_Rotation_valleys = np.pad(time_updated[valleys_neck],
 (0, max_size-len(valleys_neck)), mode='constant', constant_values=0)
Neck_Rotation_valleys = np.pad(fem_neck_rot_updated[valleys_neck],
 (0, max_size-len(valleys_neck)), mode='constant', constant_values=0)

# Rotation Around Screw: Peaks
Time_Screw_Rotation_peaks = np.pad(time_updated[peaks_screw],
 (0, max_size-len(peaks_screw)), mode='constant', constant_values=0)
Screw_Rotation_peaks = np.pad(fem_screw_rot_updated[peaks_screw],
 (0, max_size-len(peaks_screw)), mode='constant', constant_values=0)

# Neck Rotation: Valleys
Time_Screw_Rotation_valleys = np.pad(time_updated[valleys_screw],
 (0, max_size-len(valleys_screw)), mode='constant', constant_values=0)
Screw_Rotation_valleys = np.pad(fem_screw_rot_updated[valleys_screw],
 (0, max_size-len(valleys_screw)), mode='constant', constant_values=0)


# Create a DataFrame
peak_valley_data = {'Cycle': np.round(np.linspace(1, max_size, max_size),0),
        'Time (s): Varus Collapse Peaks': Time_Varus_Collapse_peaks,
        'Varus Collapse: Peaks': Varus_Collapse_peaks,
        'Time (s): Varus Collapse Valleys': Time_Varus_Collapse_valleys,
        'Varus Collapse: Valleys': Varus_Collapse_valleys,
        'Time (s): Neck Rotation Peaks': Time_Neck_Rotation_peaks,
        'Neck Rotation: Peaks': Neck_Rotation_peaks,
        'Time (s): Neck Rotation Valleys': Time_Neck_Rotation_valleys,
        'Neck Rotation: Valleys': Neck_Rotation_valleys,
        'Time (s): Rotation Around Screw Peaks': Time_Screw_Rotation_peaks,
        'Rotation Around Screw: Peaks': Screw_Rotation_peaks,
        'Time (s): Rotation Around Screw Valleys': Time_Screw_Rotation_valleys,
        'Rotation Around Screw: Valleys': Screw_Rotation_valleys}

peak_valley_data = pd.DataFrame(peak_valley_data)
print(peak_valley_data)

# Update the output filename with '_Summary'
filename = filepath.replace('/content/', '')
filename = filename.replace('.xlsx', '')
filename = filename + '_Summary.xlsx'

#Export the DataFrame to an Excel file
with pd.ExcelWriter(filename) as writer: # Create an ExcelWriter object
    # Write each DataFrame to a different sheet
    Summary_table.to_excel(writer, sheet_name='Summary', index=False)
    peak_valley_data.to_excel(writer, sheet_name='Peak-Valley Data',
                              index=False)

# prompt: an interactive scatter plot using jupyter widgets
from ipywidgets import interact, interactive, fixed, interact_manual
import ipywidgets as widgets

# Assuming you have a DataFrame named 'df' with your data
# Replace 'x_column' and 'y_column' with the actual column names in your
# DataFrame

df = peak_valley_data

def interactive_scatter(x_column, y_column):
  plt.figure(figsize=(8, 6))
  plt.scatter(df[x_column], df[y_column])
  plt.xlabel(x_column)
  plt.ylabel(y_column)
  plt.title('Interactive Scatter Plot')
  plt.show()

# Create dropdown widgets for x and y columns
x_widget = widgets.Dropdown(
    options=df.columns,
    value=df.columns[0],  # Default value for x-axis
    description='X-Axis:'
)
y_widget = widgets.Dropdown(
    options=df.columns,
    value=df.columns[1],  # Default value for y-axis
    description='Y-Axis:'
)

# Use interact to create the interactive plot
interact(interactive_scatter, x_column=x_widget, y_column=y_widget);

# Create dropdown widgets for x and y columns
x_widget = widgets.Dropdown(options=df.columns, value=df.columns[0], description='X-Axis:') # Default value for x-axis
y_widget = widgets.Dropdown(options=df.columns, value=df.columns[1], description='Y-Axis:') # Default value for y-axis
interact(interactive_scatter, x_column=x_widget, y_column=y_widget); # Use interact to create the interactive plot